#!/bin/sh

# hayanime
# Easy and Lightweight Program that lets you watch anime without interruptions.
#
# Author: TheGlockMisc
# Date: November 23, 2021
# License: GPL-3.0
#
# Github: https://github.com/TheGlockMisc/hayanime
#
# DISCLAIMER
# I don't own or manage any server on the internet that scrapes by this tool,
# and i'm not reponsible of any illegal uses of this tool.
# This tool is for educational purposes only. Use at your own Risk.

VERSION="v2.1.1"

# Variables
OWNPID="${$}"
base_url="https://animixplay.to"
base_url_ani="https://6ani.me"
base_url_go="https://goload.pro"
user_agent='Mozilla/5.0 (Linux; Android 8.1.0; vivo 1801) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/10.2 Chrome/71.0.3578.99 Mobile Safari/537.36'
termcols="$(stty size)" termcols="${termcols##* }"
currtrunc="$(printf '%s' "${PWD:=$(pwd)}" | sed -E 's_(.{10}).*(.{20})_\1...\2_g')"
userguest="$(whoami)"
saveterm="$(stty -g)"
defifs="${IFS}"
player="mpv"
server="default"
download_mode="false"

# Dynamic search APIs (for stability)
sear_hash="ic5qwh28vwloyjo28qtg
w0ltfgqz8y3ygjozgs4v
nmtvjxdtx42qdwktdxjfoikjq
2snpxh6dqulm1c0ppnivgzdt
gykngaxzenja64nweh3a2kz2
bgmvcle5cq9kjycjokrtwii9e
ij7p9towl8uj4qafsopjtrjk
6kdst8yelac6xagbyeuspg7ua"
rand_num="$(awk -v min=1 -v max=8 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')"
rand_mizer="$(printf '%s' "${sear_hash}" | sed -n "${rand_num}p")"
search_base_api="https://v1.${rand_mizer}.workers.dev/"
unset rand_num rand_mizer sear_hash

# PATH env for VLC
export PATH="${PATH}:/mnt/c/Program Files/VideoLAN/VLC:/mnt/c/Program Files (x86)/VideoLAN/VLC:/c/Program Files/VideoLAN/VLC:/c/Program Files (x86)/VideoLAN/VLC"

# Receive Terminal Signal
trap "save_terminal && printf '%b' '\n' && exit 2" INT HUP


# Terminal States
save_terminal(){
	printf "\033[?25h"	# Show Cursor
	printf "\033[0m"	# Normal State of Colors
	stty "${saveterm}"	# Rollback stty settings
	IFS="${defifs}"	# Set to default IFS
}

sanitize_terminal(){
	printf '%b' "\033[${1}A"
	printf "%${2}s" | sed "s_[[:space:]]_\n$(printf "%${termcols}s")_g"
	[ -n "${3}" ] && printf '%b' "\033[${3}A"
}

hideCursor(){
	printf "\033[?25l"
	trap "showCursor && exit 2" 2
}

showCursor(){
	printf "\033[?25h"
	save_terminal
}


# Color Processors
err(){
	printf "\033[38;5;1m%b\033[0m\n" "${1}" >&2
}

die(){
	err "${1}"
	save_terminal
	exit 1
}

inf(){
	printf "\033[38;5;3m%b\033[0m\n" "${1}"
}

suc(){
	printf "\033[38;5;2m%b\033[0m\n" "${1}"
}

input_questions(){
	printf '\033[38;5;140m%s\033[38;5;175m%s\033[38;5;140m%s\033[38;5;175m%s\033[38;5;140m%s\n%s\033[0m\033[38;5;147m%s\033[0m%s' " ┌─[" "hayanime${VERSION}@${userguest}" "]─[" "${currtrunc}" "]" " └──╼ " "[+] " "${1}"
}


# Misc and Tools
update_script(){
	script_ind="$(curl -sL -A "${user_agent}" "https://raw.githubusercontent.com/TheGlockMisc/hayanime/master/hayanime")" || die "An error occured while retrieving from github"
	script_ind="$(printf '%s\n' "${script_ind}" | diff -u "${0}" -)"
	if [ -z "${script_ind}" ]; then
		suc "Cool, Script is up to date!"
		save_terminal
		exit 0
	else
		if printf '%s\n' "${script_ind}" | patch -s "${0}" - ; then
			suc "Script has been sucessfully Updated, Enjoy!"
			save_terminal
			exit 0
		else
			die "Can't update, An Exception Occured."
		fi
	fi
}

dep_check(){
	for deppack; do
		if ! command -v "${deppack}" >/dev/null ; then
			[ "${deppack}" = "xdg-open" ] || err "Program \"${deppack}\" is not installed."
			case "${deppack}" in
				aria2c)
					err "To install aria2c, Type <your_package_manager> aria2"
					;;
				vlc.exe)
					err "Set the absolute path of vlc.exe in your \"\$PATH\" Environment Variable"
					;;
				mpv)
					inf "[Note: For Android Users Only] Please run this to use mpv-android:"
					suc "curl -sL -o \"\${PREFIX}/bin/mpv\" \"https://raw.githubusercontent.com/TheGlockMisc/mpv-android-argparse/master/mpv\" && chmod +x \"\${PREFIX}/bin/mpv\""
					inf "For LINUX users:"
					suc "sudo <your_package_manager> mpv"
					;;
				xdg-open)
					err "Built-in player is only for Android Users"
					;;
			esac
			exit 1
		fi
	done
}

dl_manager(){
	case "${2}" in
		*master.m3u8*|*m3u8*|*manifest*)
			dep_check "ffmpeg"
			idx_comp "${2}"
			ffmpeg -loglevel error -stats -referer "${1}" -i "${2}" -map "0:a:$((${qualvid:-1}-1))" -map "0:v:$((${qualvid:-1}-1))" -c copy "${3}"
			xco="${?}"
			;;
		*)
			dep_check "aria2c"
			printf '%b' "\n"
			aria2c -x 5 -s 5 --console-log-level=error --referer="${1}" --check-certificate="false" --download-result="hide" --auto-save-interval="0" "${2}" -o "${3}"
			xco="${?}"
			;;
	esac
	printf '%b\n' "\007"
	if [ "${xco}" = "0" ]; then
		suc "Downloading Episode ${epi_selected} Done!!"
	else
		err "Downloading Episode ${epi_selected} Failed..."
	fi
}

hist_handler(){
	[ -e ~/.hayanihist ] || touch ~/.hayanihist 2>/dev/null		# Supress Incase of the Directory is Unwritable
	if [ "${1}" = "append" ]; then
		[ -w ~/.hayanihist ] || die "Hist file is Unwritable, Make sure you have access to write to HOME directory"
		sed -i "/${3}/d" ~/.hayanihist
		printf '%s¢%s€%s£%s\n' "${2##*"${base_url}"}" "${3}" "${4}" "${5}" >> ~/.hayanihist
		unset path
	else
		main_interface
		hist_data="$(sed -E '1!G;h;$!d' ~/.hayanihist | uniq | head -n "${hist_limt:-25}")"
		hist_count="$(printf '%s' "${hist_data}" | awk 'BEGIN{c=0} //{c++} END{print c}')"
		[ "${hist_count}" = "0" ] && die "History File is Empty, Watch anime first"
		table_ui_hist "${hist_data}"
		input_questions "Pick a Number: "
		read -r hist_picked
		hist_picked="$(printf '%s' "${hist_picked}" | tr -dc '0-9')"
		while [ "${hist_picked:-$((hist_count + 2))}" -gt "${hist_count}" ]; do
			err "Out of Bounds... Pick between 1-${hist_count}, or type 0 to exit."
			input_questions 'Pick a Number: '
			read -r hist_picked
			hist_picked="$(printf '%s' "${hist_picked}" | tr -dc '0-9')"
		done
		[ -z "${hist_picked}" ] && die
		if printf '%s' "${hist_picked}" | grep -q '^0'; then save_terminal && exit 0; fi
		# Assign the Infos by declaring
		hist_data="$(printf '%s' "${hist_data}" | sed -n "${hist_picked}"p)"
		query_result="${hist_data%%¢*}#"
		ani_searched="$(printf '%s' "${hist_data}" | sed -E 's_.*¢(.*)€.*_\1_g')"
		ani_selected="1" qual_stream="high" query_count="1"
		epi_selected="$(printf '%s' "${hist_data}" | sed -E 's_.*€(.*)£.*_\1_g')"
		player="${hist_data##*£}" 
	fi
}

idx_comp(){
	stream_ind="$(curl -sL "${1}" -A "${user_agent}" | grep '#EXT-X-STREAM-INF')"
	for qual_var in ${qualvidman} 1080 720 480 360 240; do
		qualvid="$(printf '%s' "${stream_ind}" | grep -Fn "${qual_var}" | cut -d':' -f 1)"
		[ -n "${qualvid}" ] && break
		inf "Quality not found, Switching to high quality as possible"
		unset qualvid
	done
	[ -z "${qualvid}" ] && err "Can't get the Quality, switching to auto" && qualvid="auto"
}


# UI Setup Design
ui_banner(){
	while IFS= read -r line; do
		printf "\033[38;5;$(($$ % 60))m%*s\033[0m\n" "$(((${#line}+termcols)/2))" "${line}"
	done <<-"EOF"
	 _   _                         _                
	| | | | __ _ _   _  __ _ _ __ (_)_ __ ___   ___ 
	| |_| |/ _` | | | |/ _` | '_ \| | '_ ` _ \ / _ \
	|  _  | (_| | |_| | (_| | | | | | | | | | |  __/
	|_| |_|\__,_|\__, |\__,_|_| |_|_|_| |_| |_|\___|
	             |___/           早にめ。。。
	EOF
}

main_interface(){
	clear
	ui_banner
	while IFS= read -r line; do
		printf "%*s\n" "$(((${#line}+termcols)/2))" "${line}"
	done <<-EOF
	
	Version: ${VERSION}
	Fast and Reliable program to Watch anime...
	EOF
	printf '%b' "\n"
}

show_aniinf(){
	while IFS= read -r line; do
		printf "\033[38;5;144m%*s\033[0m\n" "$(((${#line}+termcols)/2))" "${line}"
	done <<-EOF
	
	Anime Infos:
	${1}
	
	EOF
}

show_help(){
	while IFS= read -r line; do
		printf "%b\n" "${line}"
	done <<-EOF
	Easy and Lightweight Program that lets you watch anime without interruptions.
	
	 Usage:
	    ${0##*/} <args>
	    ${0##*/} -v | -h
		
	 Options:
	    -q [low|normal|high]\t: Choose specific quality
	    -s [default|(1-5)]\t\t: Select server
	    -p [vlc|built-in]\t\t: Use specific video player (default: mpv)
	    --dub\t\t\t: Watch Dubbed Anime
	    -d\t\t\t\t: Download Mode
	    -H\t\t\t\t: Play Anime from History
	    --hist-limit=[n]\t\t: Limit the number of choices to be showed up in stdout (default: 25)
	    -u\t\t\t\t: Update to the latest Version
	    -v\t\t\t\t: Print Version and Exit
	    -h\t\t\t\t: Print Help
	
	The quality selection on "-p built-in" is not available. (default: Auto)
	Server Selection is optional, Server 1 is fast but most of the time 
	it always break. Incase of the default ones is not working, please choose
	the backup. Built-in video player is only for termux (Android) users.
	
	Exit Codes:
	    [0] : No Error
	    [1] : An Error occured or the process was destructed by an Exception
	    [2] : Exited using "Iterrupt"
	
	More info: <https://github.com/TheGlockMisc/hayanime/>.
	EOF
}

table_ui(){
	data="$(printf '%s' "${1}" | sed -E 's_.*#(.*)_\1_g' | sed -E "s_(.{$((termcols-26))}).*(.{5})(€.*)_\\1...\\2\\3_g;\$a\\$(printf "%*s" "$((termcols-10))" "€2022")\\" | nl -w4 -s"  €" | column -s "€" -t | sed '$d')"
	printf "\n\033[48;5;59m%3s#%3s\033[0m\033[48;5;238m%2sAnime Name%$((termcols - 30))s\033[0m\033[48;5;59m%2sReleased%1s\033[0m\n"
	while IFS= read -r line; do
		len="$((termcols - ${#line}))"
		printf "\033[48;5;236m%s%${len}s\033[0m" "${line}"
	done <<-EOF
	${data}
	EOF
	printf "\033[48;5;59m%7s\033[0m\033[48;5;238m%$((termcols - 18))s\033[0m\033[48;5;59m%11s\033[0m\n\n"
	unset data line len
}

table_ui_hist(){
	data="$(printf '%s' "${1}" | sed -E 's_.*¢(.*)£.*_\1_g' | sed -E "s_(.{$((termcols-26))}).*(.{5})(€.*)_\\1...\\2\\3_g;\$a\\$(printf "%*s" "$((termcols-10))" "€2022")\\" | nl -w4 -s"  €" | column -s "€" -t | sed '$d')"
	printf "\n\033[48;5;59m%3s#%3s\033[0m\033[48;5;238m%2sAnime Name%$((termcols - 30))s\033[0m\033[48;5;59m%2sEpisode%2s\033[0m\n"
	while IFS= read -r line; do
		len="$((termcols - ${#line}))"
		printf "\033[48;5;236m%s%${len}s\033[0m" "${line}"
	done <<-EOF
	${data}
	EOF
	printf "\033[48;5;59m%7s\033[0m\033[48;5;238m%$((termcols - 18))s\033[0m\033[48;5;59m%11s\033[0m\n\n"
	unset data line len
}

choose_from_menu(){
	prompt="${1}"
	shift 1
	options="${*}" cur="0" index="0"
	count="$(printf '%s' "${options}" | awk 'END{print NR}')" 
	up="$(printf '%b' "\033[A")" down="$(printf '%b' "\033[B")" escchar="$(printf '%b' "\033")" pgup="$(printf '%b' "\033[5~")" pgdn="$(printf '%b' "\033[6~")"
	hideCursor
	stty -echo -icanon min 1 time 0
	printf '%b\n' "${prompt}"
	while true; do
		index="0"
		IFS='
		'
		for o in ${options}; do
			if [ "${index}" = "${cur}" ]; then 
					printf '%b\n' "  \033[0;32mᐅ\033[0m  \033[7m${o}\033[0m"
			else
					printf '%s\n' "     ${o}"
			fi
			index="$(( index + 1 ))"
		done
		IFS="${defifs}"
		key="$(dd bs=10 count=1 2>/dev/null)"
		case "${key}" in
			"${up}"|w|W)
				cur="$(( cur - 1 ))"
				[ "${cur}" -lt "0" ] && cur="0"
				;;
			"${down}"|s|S)
				cur="$(( cur + 1 ))"
				[ "${cur}" -ge "${count}" ] && cur="$(( count - 1 ))"
				;;
			"${escchar}"|q|Q)
				showCursor
				exit 0
				;;
			h|H)
				sanitize_terminal "$((count + 1))" "$((count + 1))" "$((count + 1))"
				while IFS= read -r lines; do
					suc "${lines}"
				done <<-EOF
				
				 Keybindings:
				   Q or ESC\t\t: Exit
				   W or Button UP\t: to go up
				   S or Button Down\t: to go down
				   PGUP\t\t\t: to go to the First Choice
				   PGDN\t\t\t: to go to the Last Choice
				
				Press ENTER to Continue...
				EOF
				read -r ar && printf '%s' "${ar}" >/dev/null && unset ar
				# Sanitize Terminal
				sanitize_terminal "9" "10"
				[ "${count}" -ge "8" ] && printf '%b' "\033[$((8-count))A" || printf '%b' "\033[$((9-count))A"
				;;
			"${pgup}")
				cur="0"
				;;
			"${pgdn}")
				cur="$((count - 1))"
				;;
			"")
				menu_result_menu="${cur}"
				showCursor
				break
				;;
		esac
		printf '%b\r' "\033[${count}A"
	done
}


# Parsers and Searching
search(){
	if [ -z "${ani_searched}" ]; then
		input_questions 'Search Anime Here: '
		read -r ani_searched
	fi
	ani_searched="$(printf '%s' "${ani_searched}" | tr -d '[:punct:]')"
}

result_searched(){
	query_result="$(curl -sLk "${search_base_api}" -d "q2=${1}&origin=1&root=animixplay.to" | tr -d "\\\\" | grep -oP 'name.*?a href="([^"]*)".*?title="([^"]*)".*?(Released: [0-9]*|\&nbsp\;)' | sed -E 's_\&nbsp\;_Released: TBA_g;s_.*href="([^\"]*)".*title="([^\"]*)".*Released:.(TBA|[0-9]*).*_\1\#\2 €\3_')"
	[ -z "${query_result}" ] && die "Exception: No Results Found"
	[ "${dub_mode}" = 'true' ] && query_result="$(printf '%s' "${query_result}" | grep '[d|D]ub')" || query_result="$(printf '%s' "${query_result}" | grep -v '[d|D]ub')"
	query_scraped="$(printf '%s' "${query_result}" | sed -E 's_.*#(.*)_\1_g')"
	table_ui "${query_scraped}"
	query_count="$(printf '%s' "${query_scraped}" | awk 'BEGIN{c=0} //{c++} END{print c}')"
	[ "${query_count}" = "0" ] && die "Exception: Not Found"
}

selector(){
	if [ -z "${ani_selected}" ]; then
		result_searched "${ani_searched}"
		input_questions 'Pick Here By Number: '
		read -r ani_selected
	fi
	ani_selected="$(printf '%s' "${ani_selected}" | tr -dc '0-9')"
	while [ "${ani_selected:-$((query_count + 2))}" -gt "${query_count}" ]; do
		err "Out of Bounds... Pick between 1-${query_count}, or type 0 to exit."
		input_questions 'Pick Here By Number: '
		read -r ani_selected
	done
	if printf '%s' "${ani_selected}" | grep -q '^0'; then save_terminal && exit 0; fi
	anime_selected="$(printf '%s' "${query_result}" | sed -E -e "${ani_selected}"'!d' -e "s_(.*)#.*_${base_url}\1_")"
}

epi_counter(){
	epilist_index=$(curl -sLk "${1}" -A "${user_agent}" | sed -E '/<div id="epslistplace" style="display:none">/,/<\/div>/!d;s_"ep0"_"-1"_g')
	epi_total=$(printf '%s' "${epilist_index}" | sed -nE 's_.*eptotal":([^\,]*),.*_\1_p')
	aniinf="$(printf '%s' "${epilist_index}" | sed -nE 's_.*span.*genredata">([^\<]*)</span>.+br>_Genre: \1_p; s_.*span.*status">([^\<]*)<.*_\1_p')"
	[ -z "${epi_total}" ] && die "Exception: Anime is Not released yet, Or your IP is Blocked"
}

episode_selector(){
	epi_counter "${anime_selected}"
	if [ -z "${epi_selected}" ]; then
		show_aniinf "${aniinf}"
		[ "${epi_total}" = '1' ] && inf "Feat: Autoselect when only one episode exist" && epi_selected="1"
		[ -z "${epi_selected}" ] && input_questions "Episode [1-${epi_total}]: " && read -r epi_selected
	fi
	epi_selected="$(printf '%s' "${epi_selected}" | tr -dc '0-9\.\-')"
	epi_whole="$(printf '%s' "${epi_selected}" | sed -E 's_(\.[0-9]*|^[0-9]*\-)__g')"
	while [ "${epi_whole:-$((epi_total + 2))}" -gt "${epi_total}" ]; do
		err "Exception: Episode does not Exist"
		input_questions "Episode [1-${epi_total}]: "
		read -r epi_selected
		epi_selected="$(printf '%s' "${epi_selected}" | tr -dc '0-9\.\-')"
		epi_whole="$(printf '%s' "${epi_selected}" | sed -E 's_(\.[0-9]*|^[0-9]*\-)__g')"
	done
	[ "${download_mode}" = "true" ] || epi_selected="${epi_selected##*-}"
	anime_name_crafted="$(printf '%s' "${anime_selected}" | sed -E 's_https://animixplay.to/v1/__g;s_-_ _g;s_\b(.)_\u\1_g')"
	file_name_crafted="$(printf '%s' "${anime_selected}" | sed -E "s_https://animixplay.to/v1/__g;s_\$_-episode-${epi_selected}_g").mp4"
	title_crafted="$(printf '%s %s' "${anime_name_crafted}" "Episode ${epi_selected}" )"
}

qualitypicker(){
	if [ -z "${qual_stream}" ]; then
		if printf '%s' "${server}" | grep -qE 'dood|mpup' || [ "${player}" = "built-in" ]; then
			qual_stream="high"
		fi
		[ -z "${qual_stream}" ] && input_questions 'Quality: ' && read -r qual_stream
	fi
}


# Scraper & Streams
id_grepper(){
	if printf '%s' "${epi_selected}" | grep -q '[0-9]*\.[0-9]'; then
		idserv="$(printf '%s' "${epilist_index}" | sed -E 's_,"_\n_g' | sed -E -e '/^([0-9]*|[0-9]*\.[0-9]*|\-[0-9]*)\x22/!d' -e "/^(${epi_selected})\x22/"'!d' -e 's_.*:"(.*?)".*_\1_' -e 's_\#\#_\n_g' | grep -oE '(ed/video/|com/video/|id=|/videoembed/|player.html#)([^\&\?\#]*)' | sort -V | head -n 1)"
	else
		idserv="$(printf '%s' "${epilist_index}" | sed -E 's_,"_\n_g' | sed -E -e '/^([0-9]*|[0-9]*\.[0-9]*|\-[0-9]*)\x22/!d' -e "/^($((epi_selected - 1)))\x22/"'!d' -e 's_.*:"(.*?)".*_\1_' -e 's_\#\#_\n_g' | grep -oE '(ed/video/|com/video/|id=|/videoembed/|player.html#)([^\&\?\#]*)' | sort -V | head -n 1)"
	fi
	[ -z "${idserv}" ] && die "Exception: Not Found"
	case "${idserv}" in
		*id=*)	idserv="${idserv##*id=}"	;;
		*player.html#*)	idserv="${idserv##*\#}" server="defdir"	;;
		*ed/video/*)	idserv="${idserv##*/}" server="daily"	;;
		*com/video/*)	idserv="${idserv##*/}" server="vim"	;;
		*/videoembed/*)	idserv="${idserv##*/}" server="ok" player="mpv"	;;
		*)	die "Unknown Anime ID returned, please report this bug in Github."	;;
	esac
}

streaming_url_server(){
	if [ "${download_mode}" != "true" ]; then
		case "${server:=default}" in
			sb|dood|mpup)
					[ "${player}" = "built-in" ] && die "Built-in player is not supported in this Server"
				;;
			ok)
					[ "${player}" = "built-in" ] && player="mpv" && dep_check "mpv"
				;;
		esac
	fi
	case "${server:=default}" in
		gogo)
			cust_referer="gogoanime.fi"
			main_streaming="$(curl -sLk "${base_url_ani}/player/v1.php?id=${1}" | sed -nE 's_.*file:."([^"]*)".*_\1_p')"
			;;
		sb)
			cust_referer="sbplay2.com"
			sb_id="$(curl -sLk "${base_url_go}/streaming.php" -d "id=${1}" | sed -E '/StreamSB/!d;s_.*data-video="(.*?)".*_\1_;s_.*/e/(.*)_\1_' | tr -d '\n' | od -A n -t x1 | tr -d " |\n")"
			sbdata="616e696d646c616e696d646c7c7c${sb_id}7c7c616e696d646c616e696d646c7c7c73747265616d7362/616e696d646c616e696d646c7c7c363136653639366436343663363136653639366436343663376337633631366536393664363436633631366536393664363436633763376336313665363936643634366336313665363936643634366337633763373337343732363536313664373336327c7c616e696d646c616e696d646c7c7c73747265616d7362"
			for try_sources in sources43 sources40 sources41 sourcesx42 sourcesx38 sources36 sources37; do
				main_streaming="$(curl -sLk "https://sbplay2.com/${try_sources}/${sbdata}" -H "watchsb: streamsb" -e "${cust_referer}" -A "${user_agent}" | sed -nE 's_.*file":"([^\"]*)",.*_\1_p')"
				if printf '%s' "${main_streaming}" | grep -q "client="; then
					break
				fi
			done
			;;
		fembed)
			cust_referer="fembed.com"
			fm_url="$(curl -sLk "${base_url_go}/streaming.php" -d "id=${1}" | sed -E '/Xstreamcdn/!d;s_.*data-video="(.*?)".*_\1_;s_/v/_/api/source/_g')"
			resp_ind="$(curl -sLk -X POST "${fm_url}" -e "${fm_url}" | sed -E 's_\{"file_\n\{"file_g')"
			for qual_var in ${qualvidman} 1080 720 480 360 240; do
				main_streaming="$(printf '%s' "${resp_ind}" | sed -E "/${qual_var}p/"'!d'';s_.*file.*(https.*?)\x22,.*label.*_\1_;s_[\]__g')"
				[ -n "${main_streaming}" ] && break
				unset main_streaming
			done
			;;
		dood)
			dood_id="$(curl -sLk "${base_url_go}/streaming.php" -d "id=${1}"  | sed -E '/Doodstream/!d;s_.*data-video="(.*?)".*_\1_;s_.*/e/__g')"
			cust_referer="https://dood.pm/e/${dood_id}"
			dood_path="$(curl -A "${user_agent}" -s "${cust_referer}" | sed -nE 's_.*get\(\x27(/pass\_md5.*)\x27,.*_\1_p')"
			sleep 1.5
			dood_param="${dood_path##*"/pass_md5/"}" dood_ex="$(date +%s)"
			main_streaming="$(curl -A "${user_agent}" -s "https://dood.pm${dood_path}" -e "${cust_referer}")doodstream?token=${dood_param##*/}&expiry=${dood_ex}000"
			if printf '%s' "${main_streaming}" | grep -qE '[c|C]loudflare'; then
				unset main_streaming
			fi
			;;
		mpup)
			mpupurl="$(curl -sLk "${base_url_go}/streaming.php" -d "id=${1}"  | sed -E '/Mp4upload/!d;s_.*data-video="(.*?)".*_\1_')"
			main_streaming="$(curl -skLA "${user_agent}" "${mpupurl}" | sed -nE 's_.*embed\|(.*)\|.*blank.*\|(.*)\|(.*)\|(.*)\|(.*)\|src.*_https://\1.mp4upload.com:\5/d/\4/\3.\2_p')"
			cust_referer="${main_streaming}"
			;;
		# Substitute Servers
		daily)
			cust_referer="https://www.dailymotion.com/"
			main_streaming="$(curl -sLk "https://www.dailymotion.com/player/metadata/video/${1}" -e "${cust_referer}" | sed -E 's_.*x-mpegURL","url":"(.+?)"}].*_\1_;s_[\]__g')"
			;;
		ok)
			cust_referer="ok.ru"
			main_streaming="$(curl -skL "https://ok.ru/videoembed/${1}" | sed -nE 's_.*data-module="OKVideo".*data-options="(.*)".*data-player-container-id.*_\1_p' | sed -E 's_\\u0026_\&_g;s_&quot\;_\x22_g;s_[\]__g;s_.*(https://.*videoPlayerCdn[^\x22\x27<>]*).*_\1_')"
			;;
		vim)
			cust_referer="vimeo.com"
			[ "${qualvidman}" = "480" ] && qualvidman="520"
			main_streaming="$(curl -skL "https://player.vimeo.com/video/${1}" | sed -nE 's_.*\{"akfire\_interconnect\_quic":\{"url":"([^\"]*)","origin":"gcs","avc\_url":"[^\"]*".*fastly\_skyfire":\{"url":"([^\"]*)".*_\1\n\2_p' | tail -n 1)"
			;;
		# Catch Direct
		defdir)
			main_streaming="$(printf '%s' "${1}" | base64 -d)"
			cust_referer="${main_streaming}"
			;;
		# Main Server
		default|*)
			encodeb64="$(printf '%s' "${1}" | base64)"
			col_craft_st1="$(printf '%s%s%s' "${1}" "LTXs3GrU8we9O" "${encodeb64}" | base64)"
			main_streaming="$(curl -sk -w "%{redirect_url}" "${base_url}/api/live${col_craft_st1}" -A "${user_agent}" | sed -nE 's_.*(https://.*player.html[^\x22\x27<>]*).*_\1_p' | awk -F'#' '{print $2}' | base64 -d)"
			cust_referer="${main_streaming}"
			;;
	esac
	[ -z "${main_streaming}" ] && die "Exception: Failed to retrieve streams"
}

quality_selector(){
	case ${qual_stream:-high} in
		normal|Normal|n|N|720)
			qualvidman="720"
			;;
		worst|low|Low|l|L|360)
			[ "${server}" = "fembed" ] && qualvidman="480" || qualvidman="360"
			;;
		high|High|H|h|best|1080|*)
			qualvidman="1080"
			;;
	esac
}

launch_vid(){
	quality_selector
	streaming_url_server "${idserv}"
	case "${player}" in
		builtin|built-in)
			nohup xdg-open --content-type video/* "${main_streaming}" > /dev/null 2>&1 &
			;;
		vlc)
			nohup vlc.exe "${main_streaming}" --http-user-agent="${user_agent}" --http-referrer="${cust_referer}" --meta-title="${title_crafted}" > /dev/null 2>&1 &
			;;
		mpv|*)
			if printf '%s' "${main_streaming}" | grep -qE 'manifest|m3u8|master.m3u8'; then
				idx_comp "${main_streaming}"
			fi
			nohup mpv "${main_streaming}" --save-position-on-quit --media-title="${title_crafted}" --referrer="${cust_referer}" --vid="${qualvid:-auto}" --user-agent="${user_agent}" --tls-verify="no" > /dev/null 2>&1 &
			;;
	esac
}


# Loops and Handlers
loop(){
	main_interface
	while ps -p "${OWNPID}" >/dev/null; do
		main
		launch_vid
		main_interface
		hist_handler "append" "${anime_selected}" "${anime_name_crafted}" "${epi_selected}" "${player}"
		trunc_aniname="$(printf '%s' "${anime_name_crafted}" | sed -E "/.{$((termcols-20))}/ s_(.{$((termcols-29))}).*(.{7}\$)_\\1...\\2_g")"
		formatter_title="Now Playing: \033[4m\033[48;5;240m${trunc_aniname}\033[0m [${epi_selected}/${epi_total}]"
		printf "%*b\n\n" "$(((${#formatter_title}+termcols+8)/2))" "${formatter_title}"
		inf "Press H to show keybindings..."
		choose_from_menu "Pick based on your suit needs:" "Exit This Program
		Relaunch Episode Again
		Next Episode
		Back to Previous Episode
		Select Episode
		Search For Another Anime
		Change Quality
		Download Episode"
		[ -z "${menu_result_menu}" ] && die "Unknown Error Appeared"
		case "${menu_result_menu}" in
			0)
				die
				;;
			1)
				continue
				;;
			2)
				if printf '%s' "${epi_selected}" | grep -q '[0-9]*\.[0-9]*'; then
					epi_selected="$(printf '%s' "${epi_selected}" | sed -E 's_\.[0-9]*__g')"
				fi
				epi_selected=$((epi_selected + 1))
				unset main_streaming encodeb64 idserv
				;;
			3)
				if printf '%s' "${epi_selected}" | grep -q '[0-9]*\.[0-9]*'; then
					epi_selected="$(printf '%s' "${epi_selected}" | sed -E 's_\.[0-9]*__g')"
				fi
				epi_selected=$((epi_selected - 1))
				unset main_streaming encodeb64 idserv
				;;
			4)
				unset epi_selected main_streaming encodeb64 idserv
				main_interface
				continue
				;;
			5)
				unset ani_searched epi_selected ani_selected qual_stream main_streaming encodeb64 idserv
				main_interface
				continue
				;;
			6)
				unset menu_result_menu qual_stream main_streaming encodeb64 idserv
				choose_from_menu "\nPick and change your quality:" "High (1080p/Auto)
				Normal (720p)
				Low (480p)"
				case "${menu_result_menu}" in
					0)	qual_stream="high"	;;
					1)	qual_stream="normal"	;;
					2)	qual_stream="low"	;;
				esac
				continue
				;;
			7)
				choose_from_menu "\nWhat server do you want to use?:" "Current Server
				Server 1 (Recommended | mp4)
				Server 2 (mp4)
				Server 3 (mp4)
				Server 4 (m3u8)
				Server 5 (m3u8)"
				case "${menu_result_menu}" in
					0)	curserv="true" && dl_manager "${cust_referer}" "${main_streaming}" "${file_name_crafted}"	;;
					1)	server="mpup"	;;
					2)	server="dood"	;;
					3)	server="fembed"	;;
					4)	server="default"	;;
					5)	server="gogo"	;;
				esac
				download_mode="true"
				if [ "${curserv}" = "true" ]; then
					die
				else
					unset menu_result_menu qual_stream main_streaming encodeb64 idserv
					range_dl_handler
				fi
				;;
		esac
		unset menu_result_menu
	done
}

range_dl_handler(){
	search
	selector
	episode_selector
	qualitypicker
	slice="$(printf '%s' "${epi_selected}" | tr '-' '\n')"
	start_ep="$(printf '%s' "${slice}" | head -n 1)"
	end_ep="$(printf '%s' "${slice}" | tail -n 1)"
	[ "${end_ep:-${start_ep}}" -gt "${epi_total}" ] && die "Exception: Out of Range"
	while [ "${start_ep}" -le "${end_ep:-${start_ep}}" ]; do
		epi_selected="${start_ep}"
		episode_selector
		qualitypicker
		id_grepper
		quality_selector
		streaming_url_server "${idserv}"
		dl_manager "${cust_referer}" "${main_streaming}" "${file_name_crafted}"
		start_ep="$((start_ep + 1))"
	done
	save_terminal
	exit 0
}


# Main Functions
main(){
	search
	selector
	episode_selector
	qualitypicker
	inf "[!] Please Wait... Processing"
	id_grepper
}

main_exec(){
	if [ "${download_mode}" = "true" ]; then
		main_interface
		range_dl_handler
	else
		[ "${player}" = "mpv" ] && dep_check "mpv"
		loop
	fi
}


# Arguments Parser
arg_parser(){
	while getopts ":vhduHq:-:p:s:" opt; do
		case "${opt}" in
			v)
				printf '%s\n' "Version: ${VERSION}"
				exit 0
				;;
			h)
				show_help
				exit 0
				;;
			d)
				download_mode="true"
				;;
			u)
				update_script
				;;
			H)
				hist_handler
				;;
			-)
				case "${OPTARG}" in
					dub)	dub_mode="true"	;;
					help)	show_help && exit 0	;;
					*hist-limit*)	hist_limt="$(printf '%s' "${OPTARG}" | tr -dc '0-9')"	;;
					*)
						err "Exception: Illegal Option"
						show_help
						exit 1
						;;
				esac
				;;
			q)
				qual_stream="${OPTARG}"
				;;
			p)
				case "${OPTARG}" in
					built-in|builtin)	dep_check "xdg-open" && player="built-in"	;;
					vlc)	dep_check "vlc.exe" && player="vlc"	;;
					*)	player="mpv"	;;
					esac
				;;
			s)
				case "${OPTARG}" in
					1)	server="gogo"	;;
					2)	server="sb"	;;
					3)	server="fembed"	;;
					4)	server="dood"	;;
					5)	server="mpup"	;;
					*)	server="default"	;;
				esac
				;;
			\?)
				err "[-${OPTARG}]: is not valid Argument"
				show_help
				exit 1
				;;
			:)
				err "[-${OPTARG}]: Argument must have a Value"
				show_help
				exit 1
				;;
		esac
	done
	shift "$((OPTIND -1))"
}


# Call Functions
arg_parser "${@}"
dep_check "curl" "sed" "grep" "awk" "base64" "od" "wc" "diff" "patch"
main_exec
