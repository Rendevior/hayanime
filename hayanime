#!/bin/sh

# hayanime
# Easy and Lightweight Program that lets you watch anime without interruptions.
#
# Author: Rendevior
# Date: November 23, 2021
# License: GPL-3.0
#
# Github: https://github.com/Rendevior/hayanime
#
# DISCLAIMER
# I don't own or manage any server on the internet that scrapes by this tool,
# and i'm not reponsible of any illegal uses of this tool.
# This tool is for educational purposes only. Use at your own Risk.

VERSION="v2.5.0"

# Color Processors & UI's
err(){ [ -z "${1}" ] || printf "\033[38;5;1m%b\007\033[0m\n" "${1}" >&2 ; return 1 ;}
die(){ save_terminal ; err "${2}" >&1 ; [ "${3}" = "help" ] && show_help ; exit "${1}" ;}
inf(){ printf "\033[38;5;3m%b\033[0m\n" "${1}" ;}
suc(){ printf "\033[38;5;2m%b\033[0m\n" "${1}" ;}
clr_scr(){ printf '\033[2J\033[1;1H' ;}

save_terminal(){
	printf "\033[?25h"	# Show Cursor
	printf "\033[0m"	# Normal State of Colors / Remove Text colors
	printf '\033[?1049l\033[u' >&2	# Go back the screen
	stty "${saveterm}"	# Rollback stty settings
	IFS="${def_ifs}"		# Set to default IFS
}

sanitize_terminal(){
	printf '\033[%sA' "${1}"
	[ -n "${4}" ] && printf '\033[%sB' "${4}"
	printf "%${2}s" | sed "s_[[:space:]]_\n$(printf "\033[2K\r")_g"
	[ -n "${3}" ] && printf '\033[%sA' "${3}"
}

main_interface(){
	clr_scr
	while IFS= read -r line; do
		rnum="$(($$ % 60))"
		printf "\033[1m\033[38;5;${rnum}m%*s\033[0m\n" "$(((${#line}+term_cols)/2))" "${line}"
	done <<-"EOF"
	    __  __                        _              
	   / / / /___ ___  ______ _____  (_)___ ___  ___ 
	  / /_/ / __ `/ / / / __ `/ __ \/ / __ `__ \/ _ \
	 / __  / /_/ / /_/ / /_/ / / / / / / / / / /  __/
	/_/ /_/\__,_/\__, /\__,_/_/ /_/_/_/ /_/ /_/\___/ 
	            /____/                               
	EOF
	while IFS= read -r line; do
		printf "%*s\n" "$(((${#line}+term_cols)/2))" "${line}"
	done <<-EOF
	
	Version: ${VERSION}
	Lightweight yet Super fast...
	
	EOF
}

input_ps1(){
	printf '\033[38;5;140m ┌─[\033[38;5;175m%s\033[38;5;140m]\n └──╼ \033[0m\033[38;5;147m[%s] \033[0m%s' "${1}" "${2}" ">> " >&2
	read -r ins
	[ -n "${ins}" ] && { printf '%s' "${ins}" ; unset ins ;} || return 1 
}

table_ui(){
	printf "\n\033[48;5;59m%3s#%3s\033[0m\033[48;5;238m%2sAnime Name%$((term_cols - 30))s\033[0m\033[48;5;59m%2sReleased%1s\033[0m\n"
	while IFS= read -r line; do
		: "$((coldep += 1))"
		len="$((term_cols - ${#line}))"
		[ "${coldep}" != "1" ] && { printf "\033[48;5;235m%s%${len}s\033[0m" "${line}" ; unset coldep ; } || printf "\033[48;5;236m%s%${len}s\033[0m" "${line}"
	done <<-EOF
	$(printf '%s' "${2}" | sed -E 's_.*¢(.*)£.*_\1_g' | sed -E "s_(.{$((term_cols-26))}).*(.{5})(€.*)_\\1...\\2\\3_g;\$a\\$(printf "%*s" "$((term_cols-11))" "€2022")\\" | nl -w4 -s" €" | column -s "€" -t | tr -dc '[:print:][:space:][€¢£]' | sed '$d')
	EOF
	printf "\033[48;5;59m%7s\033[0m\033[48;5;238m%$((term_cols - 18))s\033[0m\033[48;5;59m%11s\033[0m\n\n"
	unset line len coldep
}

show_help(){
	printf '%b\n' "Easy and Lightweight Program that lets you watch anime without interruptions.

 Usage:
    ${0##*/} [-s <server>] [-q <quality>] [-p <player>] [--dub] [anime]
    ${0##*/} [--hist-limit=\"n\"] [-H] [-s <server>]
    ${0##*/} -v | -h | -D | -u

 Options:
    -q [low|normal|high]\t: Choose specific quality
    -s [default|(1-5)]\t\t: Select server
    -p [vlc|built-in]\t\t: Use specific video player (default based on OS)
    --dub\t\t\t: Watch Dubbed Anime
    -d\t\t\t\t: Download Mode
    -u\t\t\t\t: Update to the latest Version
    -v\t\t\t\t: Print Version and Exit
    -h\t\t\t\t: Print Help

More info: <https://github.com/Rendevior/hayanime/>."
}

dep_check(){
	for deppack; do
		command -v "${deppack}" >/dev/null || { [ "${deppack}" = "xdg-open" ] && err "Built-in player is only for Android Users" || err "Program \"${deppack}\" is not installed." ; is_err="1" ;}
	done
	[ "${is_err}" = "1" ] && return 1
}

update_script(){
	script_ind="$(curl -sLfk -A "${user_agent}" "https://raw.githubusercontent.com/Rendevior/hayanime/master/hayanime")" || die 1 "An error occured while retrieving from github"
	script_ind="$(printf '%s\n' "${script_ind}" | diff -u "${0}" -)"
	[ -z "${script_ind}" ] && { suc "Cool, Script is up to date!" ; die 0 ;}
	if printf '%s\n' "${script_ind}" | patch -s "${0}" - ; then
		suc "\007Script has been sucessfully Updated, Enjoy!" && die 0
	else
		die 1 "Can't update, An Exception Occured. Or it might be can't write the update to file (Make sure you run it as an Administrator/Sudo user)"
	fi
}

result_searched(){
	[ "${mode%-raw}" = "dub" ] && set -- "${@}" "dub"
	query_result="$(curl -sLk "https://api.allanime.co/allanimeapi?variables=%7B%22search%22%3A%7B%22allowAdult%22%3Afalse%2C%22allowUnknown%22%3Afalse%2C%22query%22%3A%22$(printf '%s' "${1}" | sed -E 's_[[:blank:]]_%20_g')%22%7D%2C%22limit%22%3A26%2C%22page%22%3A1%2C%22translationType%22%3A%22${2:-sub}%22%2C%22countryOrigin%22%3A%22ALL%22%7D&extensions=%7B%22persistedQuery%22%3A%7B%22version%22%3A1%2C%22sha256Hash%22%3A%229c7a8bc1e095a34f2972699e8105f7aaf9082c6e1ccd56eab99c2f1a971152c6%22%7D%7D" -A "${user_agent}" | sed -E 's_\},\{_\n_g' | sed -nE 's_.*"\_id":"([^\"]*)","name":"([^\"]*)".*quarter.*,"year":([^\}]*)\}.*"'"${2:-sub}"'":([0-9]*[^\,]*).*_\4#https://allanime.co/anime/\1#\2€\3_p')"
	[ -z "${query_result}" ] && return 1
	printf '%s' "${query_result}" | head -n 10
}

search_anime(){
	main_interface
	[ -z "${ani_searched}" ] && ani_searched="$(input_ps1 "Search your Anime Here:" "+" | tr -d '[:punct:]')"
	[ -z "${ani_selected}" ] || return 0
	query_result="$(result_searched "${ani_searched}")" || die 1 "Series does not exist"
	query_scraped="$(printf '%s' "${query_result}" | cut -d '#' -f3)"
	query_count="$(printf '%s' "${query_scraped}" | awk 'BEGIN{c=0} //{c++} END{print c}')"
	[ "${query_count}" = "0" ] && die 1 "No Results was Found"
	table_ui "normal" "${query_scraped}" >&2
}

series_select(){
	[ -z "${ani_selected}" ] && ani_selected="$(input_ps1 "Pick Here By Number:" "+" | tr -dc '0-9')" || return 0
	while [ "${ani_selected:-$((query_count + 2))}" -gt "${query_count}" ]; do
		err "Out of Bounds... Pick between 1-${query_count}, or type 0 to exit."
		ani_selected="$(input_ps1 "Pick Here By Number:" "+" | tr -dc '0-9')"
	done
	printf '%s' "${ani_selected}" | grep -q '^0' && save_terminal && exit 0
	anime_selected="$(printf '%s' "${query_result}" | sed -E -e "${ani_selected}"'!d' -e "s@.*#(.*)#.*@\1@")"
	anime_id="${anime_selected##*/}"
	epi_total="$(printf '%s' "${query_result}" | sed -E -e "${ani_selected}"'!d' -e "s@(.*)#.*#.*@\1@")"
	[ -z "${epi_total}" ] || [ "${epi_total}" = "0" ] && die 1 "Theres no episode available for this series!"
}

episode_select(){
	if [ -z "${epi_selected}" ]; then
		[ "${epi_total}" = "1" ] && inf "Feat: Autoselect when only one episode exist" && epi_selected="1"
		[ -z "${epi_selected}" ] && epi_selected="$(input_ps1 "Episode (1-${epi_total})" "+")"
	fi
	epi_selected="$(printf '%s' "${epi_selected}" | tr -dc '0-9\.\-')"
	epi_whole="$(printf '%s' "${epi_selected}" | sed -E 's_(\.[0-9]*|^[0-9]*\-)__g')"
	while [ "${epi_whole:-$((epi_total + 2))}" -gt "${epi_total}" ]; do
		err "Episode does not exist, or Out of Range"
		epi_selected="$(input_ps1 "Episode [1-${epi_total}]:" "+" | tr -dc '0-9\.\-')"
		epi_whole="$(printf '%s' "${epi_selected}" | sed -E 's_(\.[0-9]*|^[0-9]*\-)__g')"
	done
	end_ep="${epi_selected##*-}" end_ep="${end_ep%%.[0-9]*}"
	epi_selected="${epi_selected%%-*}"
	printf '%s' "${epi_selected}" | grep -q '[0-9]*\.[0-9]*' && is_half="1"
	[ "${is_half}" != "1" ] && [ "${epi_selected}" -gt "${end_ep:-${epi_selected}}" ] && die 1 "Invalid Range"
	anime_name_crafted="$(printf '%s' "${query_scraped}" | sed -E -e "${ani_selected}"'!d' -e 's_€.*__g;s_\b(.)_\u\1_g')"
	file_name_crafted="$(awk -v "i=${anime_name_crafted}" 'BEGIN{gsub(/[^a-zA-Z0-9 ]/,"",i);a=tolower(i);gsub(/ /,"-",a);print a}')-episode-${epi_selected}"
}

quality_select(){
	[ -z "${2}" ] && return 1
	[ "${mode}" = "sub-raw" ] && set -- "${1}" "$(printf '%s' "${2}" | awk -F "#" '/^https:.*m3u8.*[Hh]ls.*/{print;next}{a[++c]=$1}END{for (i=c;i;i--) print a[i]}' | head -n 1)"
	case "${2}" in
		*wixmp*)	set -- "${1}" "$(printf '%s' "${2}" | awk -F"," '{split($0,a,","); for (i=2;i<=NF;i++) if ($i ~ /[0-9]+p/) print a[1]""$i"/mp4/file.mp4/index-v1-a1.m3u8"}')"	;;
		*crunchyroll*|*v.vrv*)	set -- "${1}" "$(curl -sLk "${2}" -A "${user_agent}" | awk '/^#EXT-X-STREAM-INF/{res=$0;sub(/.*RESOLUTION=/,"",res);sub(/,.*/,"",res)}/^http/{print $0"#"res}' | sort -t'#' -k2 -nr)"	;;
	esac
	printf '%s' "${2}" | IFS='' read -r line || { printf '%s' "${2%%#*}" ; return 0 ; }
	reslt="$(case "${1}" in
		high)	printf "%s" "${2}" | head -n1	;;
		low)	printf "%s" "${2}" | grep -E '#.*[3-4][0-9]' | tail -n1	;;
		*)	printf "%s" "${2}" | grep -m 1 "${1}"	;;
	esac)" || reslt="$(printf "%s" "${2}" | head -n1)"
	[ -z "${reslt}" ] && return 1
	printf '%s' "${reslt}" | cut -d'#' -f1
}

get_apis(){
	payload="%7B%22showId%22%3A%22${1}%22%2C%22translationType%22%3A%22${3%-raw}%22%2C%22episodeString%22%3A%22${2}%22%7D&extensions=%7B%22persistedQuery%22%3A%7B%22version%22%3A1%2C%22sha256Hash%22%3A%221f0a5d6c9ce6cd3127ee4efd304349345b0737fbf5ec33a60bbc3d18e3bb7c61%22%7D%7D"
	[ -z "${urls}" ] && { export urls ; urls="$(curl -sLfk -H "Origin: ${base_url}" "https://api.${base_url#*//}/allanimeapi?variables=${payload}" -A "${user_agent}" -e "${base_url}" | sed -E 's_\},\{_}\n{_g' | sed -n -E '/"Gl"/d;s_.*sourceUrl":"([^\"]+)".*priority":([^\,]*),.*sourceName":"([^\"]*)".*_\1|\2|\3_p' | sort -t "|" -k2 -nr | sed -E '/apivtwo/ s_^_https://allanimenews.com_g;s_clock_clock.json_g')" ;}
	[ -z "${urls}" ] && return 1
	[ "${3}" = "sub-raw" ] && set -- "${1}" "${2}" "${3}" "raw"
	str_api="$(case "${4}" in
		# Picks random stream
		[Rr]and)	printf '%s' "${urls}" | grep -v -E '[Rr]aw|sbplay|streamsb|streamlare|[Oo]ther' | awk -F'|' 'BEGIN{srand();while(getline){a[++n]=$1}for(i=n;i;i--){j=int(rand()*i)+1;t=a[i];a[i]=a[j];a[j]=t}}END{for(i=1;i<=n;i++)print a[i]}' | head -n 1	;;
		# Picks either `Default or Default B` stream
		[Dd]ef[1-2]|1)	printf '%s' "${urls}" | sed -n -E '/\|[Dd]efault.*/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `S-mp4` stream
		[Ss]mp4|2)	printf '%s' "${urls}" | sed -n -E '/\|[Ss]-mp4$/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `YT` stream
		[Yy]t|3)	printf '%s' "${urls}" | sed -n -E '/\|[Yy]t$/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `AC` stream
		[Aa]c|4)	printf '%s' "${urls}" | sed -n -E '/\|[Aa]c$/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `Luf` stream
		[Ll]uf|5)	printf '%s' "${urls}" | sed -n -E '/\|[Ll]uf-mp4$/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `Ok` stream
		[Oo]k|6)	printf '%s' "${urls}" | sed -n -E '/\|[Oo]k$/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `Uv-mp4` stream
		[Uu]v|7)	printf '%s' "${urls}" | sed -n -E '/\|[Uu]v-mp4$/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks `mp4upload` stream (decent at downloading / low file size)
		[Mm]p4up|8)	printf '%s' "${urls}" | sed -n -E '/mp4up/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		[Rr]aw)	printf '%s' "${urls}" | sed -n -E '/\|.*[Rr]aw/ {s_(.*)\|.*\|.*_\1_p;q}'	;;
		# Picks the Highest priority (for higher availability and reliability)
		[Dd]efault|*)	printf '%s' "${urls}" | cut -d'|' -f1 | grep -v -E '[Rr]aw' | head -n 1	;;
	esac)"
	[ -z "${str_api}" ] && return 1
	case "${str_api}" in
		*backup*server*|*.mp4*|*.m3u8*)	printf '%s\n' "${str_api}" | grep '[^[:space:]]' || return 1	;;
		*ok.ru*)	curl -sL -m 3 "https://odnoklassniki.ru/videoembed/${str_api##*/}" -A "${user_agent}" | sed -n -E 's_&quot;_"_g;s_\\u0026_\&_g;s_amp;__g;s_\\__g;s_.*"(.*videoPlayerCdn[^\"]+)".*_\1_p' | grep '[^[:space:]]' || return 1	;;
		*mp4up*)	curl -sLk -m 3 "${str_api}" | sed -n -E 's_.*embed\|(.*)\|.*blank.*\|(.*)\|(.*)\|(.*)\|(.*)\|src.*_https://\1.mp4upload.com:\5/d/\4/\3.\2_p' | grep '[^[:space:]]' || return 1	;;
		'')	return 1	;;
		*)	[ "${debug}" = "1" ] && printf '%s\n' "${str_api}" || curl -sLfk "${str_api}" -A "${user_agent}" -e "${base_url}" | sed -E 's_\},\{"li_}\n{"li_g' | sed -n -E 's_.*"link":"([^\"]+)".*resolutionStr":"([^\"]+)".*_\1#\2_p;s_.*url":"([^\"]+)".*"hardsub\_lang":"en-US".*_\1#en-ushls_p' | awk '!seen[$0]++'	;;
	esac
}

scrape_stream(){
	stream_links="$(get_apis "${anime_id}" "${epi_selected}" "${mode}" "${server}")" 
	stream_direct="$(quality_select "${quality}" "${stream_links}")" || die 1 "Theres an Error Appeared"
	launch_vid "${stream_direct}" "${user_agent}" "${stream_direct%/*}" "${anime_name_crafted} • [${epi_selected}/${epi_total}]"
}

debug_handler(){
	str_api="$(for item in "${@}"; do
		get_apis "${anime_id}" "${epi_selected}" "${mode}" "${item}" || err "${item}: failed to fetch"
	done)"
	unset urls
	printf '%s\n' "${str_api}" | grep -E 'blog' | xargs -P0 -I{} curl -sLfk "{}" -A "${user_agent}" -e "${base_url}" | sed -E 's_\},\{"li_}\n{"li_g' | sed -n -E 's_.*"link":"([^\"]+)".*resolutionStr":"([^\"]+)".*_\1#\2_p;s_.*url":"([^\"]+)".*"hardsub\_lang":"en-US".*_\1#en-ushls_p' | awk '!seen[$0]++'
	printf '%s\n' "${str_api}" | grep -v -E 'blog'
}

download_vid(){
	case "${1}" in
		*.m3u8*)	ffmpeg -user_agent "${3}" -referer "${2}" -i "${1}" -c copy "${4}"	;;
		*)	aria2c -x 10 -s 10 --console-log-level="error" --user-agent="${3}" --referer="${2}" --check-certificate="false" --summary-interval="0" --download-result="hide" --auto-save-interval="0" "${1}" -o "${4}"
	esac
}

launch_vid(){
	[ "${dl_mode}" = "1" ] && player="download"
	case "${player}" in
		builtin|built-in)	nohup xdg-open --content-type video/* "${1}" > /dev/null 2>&1 &	;;
		vlc)	nohup vlc.exe "${1}" --http-user-agent="${2}" --http-referrer="${3}" --meta-title="${4}" > /dev/null 2>&1 &	;;
		iina)	nohup iina "${1}" --keep-running --mpv-referrer="${3}" --no-stdin --mpv-media-title="${4}" --mpv-user-agent="${2}" --mpv-tls-verify="no" > /dev/null 2>&1 &	;;
		download)	download_vid "${1}" "${2}" "${3}" "${file_name_crafted}"	;;
		mpv|*)	nohup mpv "${1}" --save-position-on-quit --media-title="${4}" --referrer="${3}" --user-agent="${2}" --tls-verify="no" > /dev/null 2>&1 &	;;
	esac
}

arg_parser(){
	while getopts ":vhuds:q:p:-:" opts; do 
		case "${opts}" in
			v)	printf '%s\n' "${VERSION}" ; die 0	;;
			h)	show_help ; die 0 ;;
			u)	update_script	;;
			d)	dl_mode="1"	;;
		# —— Options with Values —— #
			s)	server="${OPTARG:-default}"	;;
			q)	quality="${OPTARG:-high}"	;;
			p)	player="${OPTARG:-mpv}"	;;
			-)	case "${OPTARG}" in
						dub)	mode="dub"	;;
						raw)	mode="sub-raw"	;;
						debug)	debug="1"	;;
						*)	die 1 "[--${OPTARG}]: is not a valid argument/flag" help	;;
					esac
				;;
			\?)	die 1 "[-${OPTARG}]: is not a valid argument/flag" help	;;
			*)	die 1 "[-${OPTARG}]: Argument must have a Value" help ;;
		esac
	done
	shift "$((OPTIND - 1))"
	[ -z "${ani_searched}" ] && ani_searched="${*}"
}


# Initialize
SPID="${$}"
base_url="https://allanime.co"
user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
term_cols="${COLUMNS:-$(stty size)}" term_cols="${term_cols##* }"
saveterm="$(stty -g)"
def_ifs="${IFS}"
conf_file=~/.hayanime/config.conf
hist_file="${conf_file%/*}/.hayanihist"
cache_dir="${conf_file%/*}/.cache"

[ -d "${conf_file%/*}" ] || mkdir "${conf_file%/*}"
[ -d "${cache_dir}" ] || mkdir "${cache_dir}"
[ ! -e "${conf_file}" ] && { : > "${conf_file}" ; "${conf_file}" ;} || . "${conf_file}"

# Modes are {"sub", "sub-raw", "dub"}
: "${mode:=sub}"
# Qualities are {"high", "low", "[n]p"}
: "${quality:=high}"
# Player
: "${player:=builtin}"
# Server
: "${server:=default}"

# Set boolean vars to false (as default)
: "${download_mode:=0}" "${debug_mode:=0}" "${dry_run:=0}" "${dl_mode:=0}" "${debug:=0}"

# Script boolean for conditions
: "${is_half:=0}" "${is_err:=0}"

# Receive Terminal Signal
trap 'save_terminal ; exit 0' INT HUP

main(){
	search_anime
	series_select
	episode_select
	[ "${debug}" = "1" ] && debug_handler def1 smp4 yt ac luf ok uv mp4up raw || scrape_stream
}

# Main Executions
case "$(uname -a)" in
	*ndroid*)	player="built-in"	;;
	*Darwin*)	player="iina"	;;
	*MINGW*|*MSYS*|*WSL*|*[Mm]icrosoft*)	player="vlc"	;;
	*)	player="mpv"	;;
esac

printf '\033[s\033[?1049h\033[2J\033[1;1H' >&2

dep_check curl sed grep awk base64 od diff patch xargs
arg_parser "${@}"
while [ -e "/proc/${SPID}" ]; do
	main
	case "$(input_ps1 "What do we do?" "#")" in
		1)	: "$((epi_selected+=1))"	;;
		2)	: "$((epi_selected-=1))"	;;
		3)	unset epi_selected	;;
		4)	unset ani_searched epi_selected ani_selected	;;
		5)	scrape_stream	;;
		*) 	die 0	;;
	esac
done

printf '\033[?1049l\033[u' >&2
