#!/bin/bash
# All Functions
function echoterd (){
    [[ $# == 0 ]] && return 1
    declare -i TERM_COLS="$(tput cols)"
    declare -i str_len="${#1}"
    [[ $str_len -ge $TERM_COLS ]] && {
        echo -e "$1";
        return 0;
    }
    declare -i filler_len="$(( (TERM_COLS - str_len) / 2 ))"
    [[ $# -ge 2 ]] && ch="${2:0:1}" || ch=" "
    filler=""
    for (( i = 0; i < filler_len; i++ )); do
        filler="${filler}${ch}"
    done
    printf "%s%s%s" "$filler" "$1" "$filler"
    [[ $(( (TERM_COLS - str_len) % 2 )) -ne 0 ]] && printf "%s" "${ch}"
    return 0
}

function Text_Center(){
	echo -e "$1" | sed  -e :a -e "s/^.\{1,$(tput cols)\}$/ & /;ta" | tr -d '\n' | head -c $(tput cols)
}

••(){ printf "G44DOOBWGQZDAMTEG4ZDEMBSMQ3TANZT" | base32 -d | xxd -r -ps; }
•••(){ printf "626173653634" | $(••); }
••••(){ printf "Njg3NDc0NzA3MzNhMmYyZjY3NmY2NzZmNzA2YzYxNzkzMTJlNjM2ZjZk" | $(•••) -d | $(••); }

function TimeTranslate {
  local T=$1
  local D=$((T/60/60/24))
  local H=$((T/60/60%24))
  local M=$((T/60%60))
  local S=$((T%60))
  [[ $D > 0 ]] && printf '%d D ' $D
  [[ $H > 0 ]] && printf '%d Hrs ' $H
  [[ $M > 0 ]] && printf '%d Mins ' $M
  [[ $D > 0 || $H > 0 || $M > 0 ]] && printf 'and '
  printf '%d Secs\n' $S
}

function RandomRecommendation(){
	RandGenre=$(
		wget -qO- "https://www1.gogoanime.cm/" | \
		pup 'li[class="movie genre hide"]' | \
		grep -o "/genre[^'\"<>]*" | \
		shuf | \
		sed -n '1'p
	)
	RandPickAni=$(
		wget -qO- "https://www1.gogoanime.cm$RandGenre" | \
		pup 'p.name' | \
		grep -o '".*"' | \
		awk -F['"'] '{print $4}' | \
		sed '/^$/d' | \
		shuf | \
		sed -n '1'p
	)
	echo "$RandPickAni"
}

infoarray[0]="Utility 2 and Default Server Is the best Combination Believe me"
infoarray[1]="You can change Servers at /etc/emina/down.conf"
infoarray[2]="Don't be Evil"
infoarray[3]='Want Dub mode? Just add the "-m dub" argument'
infoarray[4]="Date now is: $(date)"
infoarray[5]="Random Recommendation\n$(RandomRecommendation)"
infoarray[6]="LMAO"
infoarray[7]="Utility 2 Kinda Buggy, But Its Fast."
infoarray[8]="I'm not english speaker, All of it are Translated"
NumArr=${#infoarray[@]}
ShowIt=$(($RANDOM % $NumArr))

MainMenuMessage(){
clear
figlet -w $(tput cols) -c Emina-Cli | lolcat -S 10
echoterd "Version: v0.6.5 Beta" 2>/dev/null
Text_Center "${infoarray[$ShowIt]}"
echo
}

function UnitConversion(){
	B=$1
	KB=$(bc -l <<< "scale=2; $B/1024")
	MB=$(bc -l <<< "scale=2; $B/1024/1024")
	GB=$(bc -l <<< "scale=2; $B/1024/1024/1024")
	TB=$(bc -l <<< "scale=2; $GB/1024")
	[[ $(echo "$TB" | awk -F [.] '{print $1}') > 0 ]] && echo "$TB TB" && return
	[[ $(echo "$GB" | awk -F [.] '{print $1}') > 0 ]] && echo "$GB GB" && return
	[[ $(echo "$MB" | awk -F[.] '{print $1}') > 0 ]] && echo "$MB MB" && return
	[[ $(echo "$KB" | awk -F[.] '{print $1}') > 0 ]] && echo "$KB KB" && return
	[[ $(echo "$B" | awk -F[.] '{print $1}') > 0 ]] && echo "$B B"
}

ErrorCatchFunc(){
	tput setaf 1208; printf "[ERROR CATCHER] "; tput sgr0; printf "$1"; printf "\n"
}

RedCol() {
    printf '\033[1;31;31m%b\033[0m' "$1"
}

AdditionalInfoFunc(){
	tput setaf 2222; printf "[ADDITIONAL INFO] "; tput sgr0; printf "$1"; printf "\n"
}

NumberingFunc(){
	tput setaf 987; printf "[$1] "; tput sgr0; printf "$2"; printf "\n"
}

InputSign(){
	tput setaf 111; printf "[+] "; tput sgr0; printf "$1"; printf "\n"
}

InputSignNoBreak(){
	tput setaf 111; printf "[+] "; tput sgr0; printf "$1"
}

GreenCol() {
    printf '\033[1;31;32m%b\033[0m' "$1"
}

YellowCol() {
    printf '\033[1;31;33m%b\033[0m' "$1"
}

InfoFunc() {
    GreenCol "[INFO] "
    printf -- "%s" "$1"
    printf "\n"
}

InfoFuncDown() {
    GreenCol "[INFO] "
    printf -- "%s" "$1"
}

WarningFunc() {
    YellowCol "[WARN] "
    printf -- "%s" "$1"
    printf "\n"
}


# Handling Errors
	# Set [A] Input Errors
ErrorFunc1a() {
    RedCol "[ERROR #1a] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc2a() {
    RedCol "[ERROR #2a] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc3a() {
    RedCol "[ERROR #3a] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc4a() {
    RedCol "[ERROR #4a] "
    printf -- "%s" "$1"
    printf "\n"
}
	# Set [B] Package Errors
ErrorFunc1b() {
    RedCol "[ERROR #1b] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc2b() {
    RedCol "[ERROR #2b] "
    printf -- "%s" "$1"
    printf "\n"
}
	# Set [C] Indexing Errors
ErrorFunc1c() {
    RedCol "[ERROR #1c] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc2c() {
    RedCol "[ERROR #2c] "
    printf -- "%s" "$1"
    printf "\n"
}
	# Set [D] Server Errors
ErrorFunc1d() {
    RedCol "[ERROR #1d] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc2d() {
    RedCol "[ERROR #2d] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc3d() {
    RedCol "[ERROR #3d] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc4d() {
    RedCol "[ERROR #4d] "
    printf -- "%s" "$1"
    printf "\n"
}
	# Set [E] Config Errors at /etc/emina/down.conf
ErrorFunc1e() {
    RedCol "[ERROR #1e] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc2e() {
    RedCol "[ERROR #2e] "
    printf -- "%s" "$1"
    printf "\n"
}
	# Set [F] Argument Errors
ErrorFunc1f() {
    RedCol "[ERROR #1f] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc2f() {
    RedCol "[ERROR #2f] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc3f() {
    RedCol "[ERROR #3f] "
    printf -- "%s" "$1"
    printf "\n"
}
ErrorFunc4f() {
    RedCol "[ERROR #4f] "
    printf -- "%s" "$1"
    printf "\n"
}
	# Set [E] Permissions Error
ErrorFunc1e() {
    RedCol "[ERROR #1e] "
    printf -- "%s" "$1"
    printf "\n"
}
	
	
# Traps When the download Interrupted
trapDel(){
	trap ctrl_c INT
}

ctrl_c(){
	rm $FILEVIDNAME
	rm $FILEVIDNAME.aria2
	WarningFunc "Downloads Interrupted, File not downloaded"
	exit 1
}

trapDel1(){
	trap ctrl_c1 INT
}

ctrl_c1(){
	rm $FILEVIDNAME
	rm $FILEVIDNAME.st
	WarningFunc "Downloads Interrupted, File not downloaded!!"
	exit 1
}

function printTable(){
    local -r delimiter="${1}"
    local -r data="$(removeEmptyLines "${2}")"
    if [[ "${delimiter}" != '' && "$(isEmptyString "${data}")" = 'false' ]]
    then
        local -r numberOfLines="$(wc -l <<< "${data}")"
        if [[ "${numberOfLines}" -gt '0' ]]
        then
            local table=''
            local i=1
            for ((i = 1; i <= "${numberOfLines}"; i = i + 1))
            do
                local line=''
                line="$(sed "${i}q;d" <<< "${data}")"
                local numberOfColumns='0'
                numberOfColumns="$(awk -F "${delimiter}" '{print NF}' <<< "${line}")"
                # Add Line Delimiter
                if [[ "${i}" -eq '1' ]]
                then
                    table="${table}$(printf '%s#+' "$(repeatString '#+' "${numberOfColumns}")")"
                fi
                # Add Header Or Body
                table="${table}\n"
                local j=1
                for ((j = 1; j <= "${numberOfColumns}"; j = j + 1))
                do
                    table="${table}$(printf '#| %s' "$(cut -d "${delimiter}" -f "${j}" <<< "${line}")")"
                done
                table="${table}#|\n"
                # Add Line Delimiter
                if [[ "${i}" -eq '1' ]] || [[ "${numberOfLines}" -gt '1' && "${i}" -eq "${numberOfLines}" ]]
                then
                    table="${table}$(printf '%s#+' "$(repeatString '#+' "${numberOfColumns}")")"
                fi
            done
            if [[ "$(isEmptyString "${table}")" = 'false' ]]
            then
                echo -e "${table}" | column -s '#' -t | awk '/^\+/{gsub(" ", "-", $0)}1'
            fi
        fi
    fi
}

function removeEmptyLines(){
    local -r content="${1}"
    echo -e "${content}" | sed '/^\s*$/d'
}

function repeatString(){
    local -r string="${1}"
    local -r numberToRepeat="${2}"
    if [[ "${string}" != '' && "${numberToRepeat}" =~ ^[1-9][0-9]*$ ]]
    then
        local -r result="$(printf "%${numberToRepeat}s")"
        echo -e "${result// /${string}}"
    fi
}

function isEmptyString(){
    local -r string="${1}"
    if [[ "$(trimString "${string}")" = '' ]]
    then
        echo 'true' && return 0
    fi
    echo 'false' && return 1
}

function trimString(){
    local -r string="${1}"
    sed 's,^[[:blank:]]*,,' <<< "${string}" | sed 's,[[:blank:]]*$,,'
}

function ProgressBarModified(){
    let _progress=(${1}*100/${2}*100)/100
    let _done=(${_progress}*4)/10
    let _left=40-$_done
    _fill=$(printf "%${_done}s")
    _empty=$(printf "%${_left}s")
printf "\r$(tput setaf 111; printf "[+] "; tput sgr0)Scraping in Progress : [${_fill// /▇}${_empty// / }] ${_progress}%%"
}

function ProgressBarModifiedDown(){
    let _progress=(${1}*100/${2}*100)/100
    let _done=(${_progress}*3)/10
    let _left=30-$_done
    _fill=$(printf "%${_done}s")
    _empty=$(printf "%${_left}s")
printf "\r$(tput setaf 111; printf "[+] "; tput sgr0)Downloading : [${_fill// /▇}${_empty// / }] ${_progress}%%" && printf "      $3"
}

function ProgressBarModifiedUnin(){
    let _progress=(${1}*100/${2}*100)/100
    let _done=(${_progress}*4)/10
    let _left=40-$_done
    _fill=$(printf "%${_done}s")
    _empty=$(printf "%${_left}s")
printf "\r$(tput setaf 111; printf "[+] "; tput sgr0)Uninstalling : [${_fill// /▇}${_empty// / }] ${_progress}%%"
}
