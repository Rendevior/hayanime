#!/bin/bash
# shellcheck disable=SC1091,SC2016,SC2154

# Default Options
is_range="0"
home_dir="${HOME//\/home/}"

# For Checking Packages
function check_package(){
	for checking in "${@}"; do
		if [[ -z "$(command -v "${checking}")" ]]; then
			echo "[ERROR #1a] Package ${checking} is not installed. Please Install it before running this script." >&2
			exit 1
		fi
	done
	unset checking
}

function check_configs(){
	if ! [[ -f "${home_dir}/usr/bin/$(basename "$0")" ]]; then
		echo '[ERROR #1a] This must be run via /usr/local/sbin directory, Please do "sudo make"'
		exit 1
	elif ! [[ -f "${home_dir}/home/etc/emina/eminavars" ]]; then
		echo '[ERROR #1a] Variable file not found'
		exit 1
	elif ! [[ -f "${home_dir}/home/etc/emina/emina.conf" ]]; then
		echo '[ERROR #1a] Config file not found'
		exit 1
	fi
	source "${home_dir}/home/etc/emina/eminavars"
	source "${home_dir}/home/etc/emina/emina.conf"
}

function create_mpv(){
	echo 'am start --user 0 -a android.intent.action.VIEW -d "${1}" -e "http-header-fields" "--http-header-fields=\"Referer: ${2}\"" -n is.xyz.mpv/.MPVActivity' > "${home_dir}/usr/bin/mpv-termux"
	chmod +x "${home_dir}/usr/bin/mpv-termux"
}

function main_inputs(){
	_menu_message
	if [[ ${search_request} = "" ]]; then
		read -rp "$(design_input 'Search Anime: ')" search_request
	fi
	while true; do
		if [[ ${search_request} = "" ]]; then
			err_func "1b" "You typed Nothing, CTRL + C to Exit" >&2
			unset search_request
			read -rp "$(design_input 'Search Anime: ')" search_request
		else
			search_request=$(echo "${search_request}" | tr '[:upper:]' '[:lower:]')
			break
		fi
	done
	search_declare "${search_request}"
	if [[ ${search_selected} == "" ]]; then
		display_series "$query_results"
		read -rp "$(design_input 'Pick a Number: ')" search_selected
	fi
	while true; do
		if ! [[ "${search_selected}" =~ [0-9]* ]]; then
			err_func "2b" "Series Selected Mustn't have Punctuations Marks" >&2
			unset search_selected
			read -rp "$(design_input 'Pick a Number: ')" search_selected
		elif [[ ${search_selected} = "" ]]; then
			err_func "1b" "You typed Nothing, CTRL + C to Exit" >&2
			unset search_selected
			read -rp "$(design_input 'Pick a Number: ')" search_selected
		elif [[ ${search_selected} -gt ${query_count} ]] || [[ ${search_selected} =~ ^0$ ]]; then
			err_func "3b" "Out of range, between (1-${query_count}) only" >&2
			unset search_selected
			read -rp "$(design_input 'Pick a Number: ')" search_selected
		else
			break
		fi
	done
	get_url_series "${search_selected}"
	check_special_epi "${series_baseorigin}"
	if [[ ${epside_selected} = "" ]]; then
		read -rp "$(design_input "Episode [${old_episode}-${latest_episode}]: ")" epside_selected
	fi
	while true; do
		if ! [[ ${epside_selected} =~ [0-9]* ]]; then
			err_func "2b" "Series Selected Mustn't have Punctuations Marks" >&2
			unset epside_selected
			read -rp "$(design_input "Episode [${old_episode}-${latest_episode}]: ")" epside_selected
		fi
		if [[ ${epside_selected} =~ [0-9]*\.[0-9]*$ ]]; then
			epside_selected_repl="${epside_selected//.[0-9]*/}"
			if [[ ${epside_selected_repl} -gt ${latest_episode} ]]; then
				err_func "3b" "Out of range (${old_episode}-${latest_episode}) Episode only" >&2
				unset epside_selected epside_selected_repl
				read -rp "$(design_input "Episode [${old_episode}-${latest_episode}]: ")" epside_selected
			fi
		else
			if [[ ${epside_selected} -gt ${latest_episode} ]]; then
				err_func "3b" "Out of range (${old_episode}-${latest_episode}) Episode only" >&2
				unset epside_selected
				read -rp "$(design_input "Episode [${old_episode}-${latest_episode}]: ")" epside_selected
			fi
		fi
		if [[ ${epside_selected} = "" ]]; then
			err_func "1b" "You Entered Nothing" >&2
			unset epside_selected
			read -rp "$(design_input "Episode [${old_episode}-${latest_episode}]: ")" epside_selected
		else
			break
		fi
	done
	if ! [[ ${epside_selected} =~ - ]]; then
		if [[ ${quality_picker} = "" ]]; then
			read -rp "$(design_input 'Quality [Default: High]: ')" -e -i "${def_qual}" quality_picker
		fi
	else
		is_range="1"
	fi
	info_func "Please Wait... I'm doing my Job"
}

function load_index_result(){ index_search_result="$(curl -sL "${BASE_URL}/search.html?keyword=${1}")"; }

function search_declare(){
    search_request=$(echo "${1}" | tr "[:space:]" "+")
	load_index_result "${search_request}"
	if [[ ${dub_mode} == "1" ]]; then
		query_results=$(
			sed -n '/<div class="name">/,/./p' <<< "${index_search_result}" | \
			sed 's/^[[:space:]]*//g;s| Episode.*[0-9]*||g;/^<.*>/d;/[d|D]ub/!d' | uniq)
	else
		query_results=$(
			sed -n '/<div class="name">/,/./p' <<< "${index_search_result}" | \
			sed 's/^[[:space:]]*//g;s| Episode.*[0-9]*||g;/^<.*>/d;/[d|D]ub/d' | uniq)
	fi
    if [[ $query_results = "" ]]; then
		err_func "b1" "Seems Like No Anime Exist Based on Your Search, Try Again" >&2
		sleep 1.5
		unset search_request search_selected quality_picker epside_selected
		main_inputs
	fi
	query_count=$(grep $'\n' -c <<< "$query_results")
}

function display_series(){
	while read -r wiffles; do
		[[ "${#wiffles}" -gt 47 ]] && echo "${wiffles:0:47}..${wiffles:(-10)}" || echo "${wiffles}"
	done <<< "${1}" | nl -w1 -s"+ " | \
	printTable '+' "Num+Anime Name\n$(awk '{print $0}')"
}

function get_url_series(){
    if [[ ${dub_mode} == "1" ]]; then
		series_main_baseurl=$(
			sed -n '/<li class="video-block ">/,/<\/li>/p' <<< "${index_search_result}" | \
			grep -o "/videos/[^'\"<>]*" | sed '/[d|D]ub/!d' | sed -n "${1}"p | \
			sed "s|^|${BASE_URL}|g;s|-episode-[0-9].*||g;s|-[0-9]*$||g")
	else
		series_main_baseurl=$(
			sed -n '/<li class="video-block ">/,/<\/li>/p' <<< "${index_search_result}" | \
			grep -o "/videos/[^'\"<>]*" | sed '/[d|D]ub/d' | sed -n "${1}"p | \
			sed "s|^|${BASE_URL}|g;s|-episode-[0-9].*||g;s|-[0-9]*$||g")
	fi
	series_baseorigin=$(awk -F[/] '{print $5}' <<< "${series_main_baseurl}")
}

function check_special_epi(){
	special_epi_url="${BASE_URL}/videos/${1}-episode-1"
	special_epi_index=$(curl -sL "$special_epi_url")
	if [[ "${special_epi_index}" == "404" ]]; then
		echo "Error 404"
		exit 1
	fi
	special_epi_print=$(
		sed -n '/<ul class="listing items lists">/,/<\/ul>/p' <<< "${special_epi_index}" | \
		sed 's|^ *||g' | sed '/^.*>/d' | grep -o '[0-9]*\.[0-9]' | xargs)
	if [[ -n "${special_epi_print}" ]]; then
		info_func "This Series Have Special Episodes"
		for SpecialEpi in ${special_epi_print}; do
			echo "Episode: ${SpecialEpi}"
		done
		unset SpecialEpi
	fi
	get_number_epi="$(
		sed -n '/<ul class="listing items lists">/,/<\/ul>/p' <<< "$special_epi_index" | \
		sed -n '/<div class="name">/,/<\/div>/p' | sed 's|^ *||g' | sed '/^.*>/d' | \
		sort -V | grep -o 'Episode [0-9]*.[0-9]*' | sed 's|Episode ||g')"
	old_episode=$(echo "$get_number_epi" | tr -d " " | head -1)
	latest_episode=$(echo "$get_number_epi" | tr -d " " | tail -1)
	if [[ ${latest_episode} = "0" ]]; then
		err_func "1b" " Theres no episode found on this series"
		exit 2
	fi
}

function craft_url(){
	if [[ "${1}" =~ [0-9]*\.[0-9]*$ ]]; then
		crafted_subepi=${1//./$'\n'}
		start_subepi=$(head -n 1 <<< "${crafted_subepi}")
		end_subepi=$(tail -n 1 <<< "${crafted_subepi}")
		crafted_url_page="${BASE_URL}/videos/${series_baseorigin}-episode-${start_subepi}-${end_subepi}"
		if [[ ${dub_mode} == "1" ]]; then
			FILEVIDNAME="${series_baseorigin}-EPI${start_subepi}.${end_subepi}-DUB.mp4"
		else
			FILEVIDNAME="${series_baseorigin}-EPI${start_subepi}.${end_subepi}.mp4"
		fi
	else
		crafted_url_page="${BASE_URL}/videos/${series_baseorigin}-episode-${1}"
		if [[ ${dub_mode} == "1" ]]; then
			FILEVIDNAME="${series_baseorigin}-EPI${1}-DUB.mp4"
		else
			FILEVIDNAME="${series_baseorigin}-EPI${1}.mp4"
		fi
	fi
}

function url_get_streams(){
	PageLoaderCheck=$(
		curl -sL "${crafted_url_page}"
	)
	if [[ "$PageLoaderCheck" == "404" ]]; then
		err_func "2c" "Episode Not Found" >&2
		exit 3
	fi
	base_streaming_url=$(
		sed -n '/<div class="play-video">/,/<\/div>/p' <<< "$PageLoaderCheck" | \
		grep -o "//[^'\"<>]*" | sed 's|//|https://|g')
	if [[ "${base_streaming_url}" == "" ]]; then
		err_func "1d" "Returned 404 Not Found" >&2
		exit 3
	fi
}

function server_selector(){
	base_streaming_url_load=$(curl -sL "${1}")
	if [[ "${base_streaming_url_load}" == *"Blocked"* ]]; then
		err_func "2d" "Episode Unavailable" >&2
		exit 3
	fi
	if [[ "${server}" == "1" ]]; then
		main_rink=$(
			sed -n '/<div id="list-server-more">/,/<\/div>/p' <<< "${base_streaming_url_load}" | \
			grep -o "https[^'\"<>]*" | grep -e 'fplayer' -e 'fembed' | sed 's|/v/|/f/|g' | \
			sed -n 1p)
	elif [[ "${server}" == "default" ]]; then
		main_rink=$(
			sed -n '/<div id="list-server-more">/,/<\/div>/p' <<< "${base_streaming_url_load}" | \
			grep -o -e "https[^'\"<>]*" -e "http[^'\"<>]*" | grep 'sbplay' | \
			awk -F[/] '{print $5}' | tr -dc '[:print:]')
	fi
}

function server_fembed(){
	main_urlserver=${1}
	if [[ -z "${main_urlserver}" ]]; then
		err_func "3d" "Server Not Found" >&2
		exit 4
	elif [[ $(ls) =~ ${FILEVIDNAME} ]]; then
		err_func "2b" "You Already Downloaded the Episode" >&2
		exit 2
	fi
	refUrl=$(echo "${main_urlserver}" | awk -F[/] '{print $3}' | sed 's|^|https://|g')
	use_apiserverget=$(
		curl -sL "${main_urlserver}" | grep '$.post' | awk -F["'"] '{print $2}' | \
		sed "s|/api|${refUrl}/api|g")
	get_dl_list=$(
		curl -s -X POST -e "${refUrl}" "$use_apiserverget" | \
		grep -o "https:[^'\"<>]*" | grep 'fvs' | sed 's/[\]//g' | tac)
	if [[ ${quality_picker} =~ [h|H]igh ]]; then
		get_dl_direct=$(head -n 1 <<< "${get_dl_list}")
	elif [[ ${quality_picker} =~ [N|n]ormal ]]; then
		get_dl_direct=$(tail -n 2 <<< "${get_dl_list}" | head -n 1)
	elif [[ ${quality_picker} =~ [l|L]ow ]]; then
		get_dl_direct=$(tail -n 1 <<< "${get_dl_list}")
	fi
	if [[ -z "${get_dl_direct}" ]]; then
		err_func "5d" "Server Failed to Fetch" >&2
		exit 4
	fi
}

function server_sbplay(){
	r_play="$(printf '%s' "${1}" | code_ed)"
	feed_load="$(dgs "\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x37\x63\x37\x63")${r_play}$(dgs "\x37\x63\x37\x63\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x37\x63\x37\x63\x37\x33\x37\x34\x37\x32\x36\x35\x36\x31\x36\x64\x37\x33\x36\x32\x2f\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x37\x63\x37\x63\x33\x36\x33\x31\x33\x36\x36\x35\x33\x36\x33\x39\x33\x36\x36\x34\x33\x36\x33\x34\x33\x36\x36\x33\x33\x36\x33\x31\x33\x36\x36\x35\x33\x36\x33\x39\x33\x36\x36\x34\x33\x36\x33\x34\x33\x36\x36\x33\x33\x37\x36\x33\x33\x37\x36\x33\x33\x36\x33\x31\x33\x36\x36\x35\x33\x36\x33\x39\x33\x36\x36\x34\x33\x36\x33\x34\x33\x36\x36\x33\x33\x36\x33\x31\x33\x36\x36\x35\x33\x36\x33\x39\x33\x36\x36\x34\x33\x36\x33\x34\x33\x36\x36\x33\x33\x37\x36\x33\x33\x37\x36\x33\x33\x36\x33\x31\x33\x36\x36\x35\x33\x36\x33\x39\x33\x36\x36\x34\x33\x36\x33\x34\x33\x36\x36\x33\x33\x36\x33\x31\x33\x36\x36\x35\x33\x36\x33\x39\x33\x36\x36\x34\x33\x36\x33\x34\x33\x36\x36\x33\x33\x37\x36\x33\x33\x37\x36\x33\x33\x37\x33\x33\x33\x37\x33\x34\x33\x37\x33\x32\x33\x36\x33\x35\x33\x36\x33\x31\x33\x36\x36\x34\x33\x37\x33\x33\x33\x36\x33\x32\x37\x63\x37\x63\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x36\x31\x36\x65\x36\x39\x36\x64\x36\x34\x36\x63\x37\x63\x37\x63\x37\x33\x37\x34\x37\x32\x36\x35\x36\x31\x36\x64\x37\x33\x36\x32")"
	refUrl="sbplay2.com"
	for try_sources in sources36 sources37 sourcesx38; do
		resp_json=$(curl -sL "https://${refUrl}/${try_sources}/${feed_load}" \
			-H "watchsb: streamsb" -e "${refUrl}")
		if [[ ${resp_json} == *stream_data* ]]; then
			craft_urlname="$(grep -oP '"title":"(.*?)"' <<< "${resp_json}" | awk -F['"'] '{print $4}' | tr -dc '[:print:]').mp4"
			if [[ ${craft_urlname} =~ [[:space:]].\.mp4$ ]]; then
				craft_urlname="${craft_urlname//[[:space:]][0-9a-zA-Z].mp4/.mp4}"
			fi
			resp_url=$(grep -o "https[^'\"<>]*" <<< "${resp_json}" | grep -E 'master\.m3u8\?client=' | sed -n 1p)
			if [[ ${resp_url} =~ master\.m3u8\?client= ]]; then
				resp_body=$(curl -sL "${resp_url}" -e "${refUrl}")
				if [[ ${quality_picker} =~ [h|H]igh ]]; then
					get_dl_direct=$(sed '/#.*/d;/^$/d' <<< "${resp_body}" | tac | head -n 1 | sed "s|/hls||g;s|index.*$|${craft_urlname}|g")
				elif [[ ${quality_picker} =~ [N|n]ormal ]]; then
					get_dl_direct=$(grep '1280x' <<< "${resp_body}" | grep -o "https[^'\"<>]*" | sed "s|/hls||g;s|iframes.*$|${craft_urlname}|g")
				elif [[ ${quality_picker} =~ [l|L]ow ]]; then
					get_dl_direct=$(grep '640x' <<< "${resp_body}" | grep -o "https[^'\"<>]*" | sed "s|/hls||g;s|iframes.*$|${craft_urlname}|g")
				fi
			fi
			if [[ -n "${get_dl_direct}" ]]; then
				break
			fi
		fi
	done
	if [[ -z "${get_dl_direct}" ]]; then
		err_func "5d" "Server not Found" >&2
		exit 4
	elif [[ "${resp_json}" =~ "Not Found" ]]; then
		err_func "5d" "Server not Found" >&2
		exit 4
	fi
}

function watch_get_data(){
	craft_url "${epside_selected}"
	url_get_streams
	server_selector "${base_streaming_url}"
	if [[ ${quality_picker} = "" ]]; then
		quality_picker="high"
	elif [[ ! ${quality_picker} =~ ^([H|h]igh|[L|l]ow|[N|n]ormal)$ ]]; then
		err_func "2a" "Undefined Option, Just pick between (High, Normal, Low) Server" >&2
		sleep 2
		unset quality_picker
		main_inputs
	fi
	if [[ ${server} == "1" ]]; then
		server_fembed "${main_rink}"
	elif [[ ${server} == "default" ]]; then
		server_sbplay "${main_rink}"
	else
		err_func "2e" "Watch Mode only Available in Default and Server 1" >&2
		exit 5
	fi
	parse_hist "Watch"
	if [[ ${vid_player} == "mpv" ]]; then
		setsid -f mpv-termux "${get_dl_direct}" "${refUrl}" >/dev/null 2>&1
	elif [[ ${vid_player} == "others" ]]; then
		setsid -f am start -a android.intent.action.VIEW -t video/mpeg -d "${get_dl_direct}"  >/dev/null 2>&1
	else
		err_func "3d" "Invalid Player" >&2
		exit 2
	fi
}

function watch_anime_main(){
	while true; do
		watch_get_data
		clear
		anime_playing=$(
			while read -r wiffles; do
				[[ "${#wiffles}" -gt 47 ]] && echo "${wiffles:0:47}..${wiffles:(-10)}" || echo "${wiffles}"
			done <<< "$(sed -n "${search_selected}"p <<< "$query_results")"
		)
		_menu_message
		echo_centered "Now Playing: ${anime_playing} [${epside_selected}/${latest_episode}]"
		selections=(
			"Re-Launch Episode Again"
			"Next Episode"
			"Back to Previous Episode"
			"Select Episode"
			"Search For Another Anime"
			"Download Instead"
			"Exit the Program"
		)
		echo -e "\n"
		choose_from_menu "Pick based on your suit needs:" selected_choice "${selections[@]}"
		case "${menu_result_menu}" in
			0)
				continue
				info_func "${infowait[$(( RANDOM % ${#infowait[@]} ))]}"
				;;
			1)
				if [[ ${epside_selected} =~ [0-9]*\.[0-9]* ]]; then
					epside_selected="${epside_selected//.[0-9]*/}"
				fi
				epside_selected=$((epside_selected + 1))
				unset get_dl_direct resp_url resp_json
				info_func "${infowait[$(( RANDOM % ${#infowait[@]} ))]}"
				;;
			2)
				if [[ ${epside_selected} =~ [0-9]*\.[0-9]* ]]; then
					epside_selected="${epside_selected//.[0-9]*/}"
				fi
				epside_selected=$((epside_selected - 1))
				unset get_dl_direct resp_url resp_json
				info_func "${infowait[$(( RANDOM % ${#infowait[@]} ))]}"
				;;
			3)
				unset epside_selected get_dl_direct resp_url resp_json
				main_inputs
				continue
				;;
			4)
				unset search_request search_selected epside_selected get_dl_direct resp_url resp_json
				main_inputs
				continue
				;;
			5)
				download_instead "${refUrl}" "${get_dl_direct}" "${get_dl_direct}"
				;;
			6)
				exit 0
				;;
		esac
	done
}

function download_instead(){
# "refUrl" "get_dl_direct" "FILEVIDNAME"
	TimeStart=$(date +%s)
	aria2c -x 2 -s 2 \
		--console-log-level=error --referer="${1}" \
		--check-certificate=false --download-result=hide \
		--auto-save-interval=0 "${2}" \
		-o "${3}"
	echo
	TimeElapse=$(date +%s)
	info_func "Downloading Episode ${epside_selected} Done!!"
	AdditionalInfoFunc "Took $(TimeTranslate $(( TimeElapse - TimeStart ))) to Finish"
}

function range_download_handler(){
	parse_hist "Download"
	if [[ ${is_range} = "1" ]]; then
		slice="$(tr '-' "\n" <<< "${epside_selected}")"
		epislice_start="$(head -n 1 <<< "${slice}")"
		epislice_end="$(tail -n 1 <<< "${slice}")"
		unset slice; _menu_message
		info_func "Checking Episodes, Please Wait..."
		for (( i=epislice_start; i<=epislice_end; i++ )); do
			craft_url "${i}"
			test_page_check=$(curl -sL "${crafted_url_page}")
			if [[ "${test_page_check}" == "404" ]]; then
				err_func "2c" "Episode Not Found, Episode ${i}" >&2
				exit 3
			fi
		done
		for (( i=epislice_start; i<=epislice_end; i++ )); do
			craft_url "${i}"
			url_get_streams
			server_selector "${base_streaming_url}"
			if [[ ${server} == "1" ]]; then
				server_fembed "${main_rink}"
			elif [[ ${server} == "default" ]]; then
				server_sbplay "${main_rink}"
			else
				err_func "2e" "Download Mode only Available in Default" >&2
				exit 5
			fi
			download_instead "${refUrl}" "${get_dl_direct}" "${FILEVIDNAME}"
		done
	else
		craft_url "${epside_selected}"
		url_get_streams
		server_selector "${base_streaming_url}"
		if [[ ${server} == "1" ]]; then
			server_fembed "${main_rink}"
		elif [[ ${server} == "default" ]]; then
			server_sbplay "${main_rink}"
		else
			err_func "2e" "Download Mode only Available in Default" >&2
			exit 5
		fi
		download_instead "${refUrl}" "${get_dl_direct}" "${FILEVIDNAME}"
	fi
}

function parse_hist(){
	mode="${1}"
	quality_picker_parse="${quality_picker:-High}"; quality_picker_parse="${quality_picker_parse^}"
	series_name_parse=$(sed -n "${search_selected}"p <<< "$query_results")
	echo "${series_name_parse}#${epside_selected}#${mode}#${quality_picker_parse}" >> "$HOME/.histemina"
}

function back_hist(){
	unset search_request search_selected epside_selected
	display_hist=$(grep -E 'Download|Watch' "$HOME/.histemina" | uniq | tac)
	while read -r wiffles; do
		[[ "${#wiffles}" -gt 47 ]] && echo "${wiffles:0:47}..${wiffles:(-10)}" || echo "${wiffles}"
	done <<< "$(awk -F[#] '{print $1}' <<< "$display_hist")" | nl -w1 -s"+ " | \
	printTable '+' "Num+Anime Name\n$(awk '{print $0}')"
	read -rp "$(design_input 'Enter a Number: ')" selected_hist
	while ! [[ ${selected_hist} =~ [0-9]* ]]; do
		err_func "1a" "The input must be in Digit/Number" >&2
		read -rp "$(design_input 'Enter a Number: ')" selected_hist
	done 
	parser_selected_hist=$(sed -n "${selected_hist}"p <<< "$display_hist")
	search_request=$(awk -F[#] '{print $1}' <<< "${parser_selected_hist}")
	epside_selected=$(awk -F[#] '{print $2}' <<< "${parser_selected_hist}")
	Moode=$(awk -F[#] '{print $3}' <<< "${parser_selected_hist}")
	quality_picker=$(awk -F[#] '{print $4}' <<< "${parser_selected_hist}")
	search_selected="1"
	if [[ ${Moode} == "Download" ]]; then
		is_download="1"
	fi
}

function mainFuncs(){
	if ! [[ -e "${home_dir}/usr/bin/mpv-termux" ]]; then
		create_mpv
	fi
	check_package tput aria2c awk grep sed curl bc nl
	main_inputs
	if [[ ${is_download} == "1" ]]; then
		range_download_handler
	else
		watch_anime_main
	fi
}

function arg_parser(){
	check_configs
	while getopts ":vhdHbD-:s:e:q:t:p:" opt; do
		case "${opt}" in
			v)
				echo "${_version_script}"
				exit 0
				;;
			h)
				show_help
				exit 0
				;;
			d)
				is_download="1"
				;;
			H)
				CenteredGrid <<< "History File"
				CenteredGrid <<< "This is where all your Recent Searches/Downloads Stored"
				while read -r wiffles; do
					wiffledF1=$(awk -F[#] '{print $1}' <<< "$wiffles")
					wiffledF2=$(awk -F[#] '{print $2}' <<< "$wiffles")
					wiffledF3=$(awk -F[#] '{print $3}' <<< "$wiffles")
					wiffledF4=$(awk -F[#] '{print $4}' <<< "$wiffles")
					[[ ${#wiffles} -gt 36 ]] && echo "${wiffledF1:0:34}..${wiffledF1: (-10)}#${wiffledF2}#${wiffledF3}#${wiffledF4}" || echo "${wiffles}"
				done <<< "$(tac "$HOME/.histemina")" | \
				printTable '#' "Anime#EP#Mode#Quality\n$(awk '{print $0}')"
				exit 0
				;;
			D)
				sed -i '/^/d' "$HOME/.histemina"
				exit 0
				;;
			b)
				back_hist
				;;
			-)
				case ${OPTARG} in
					dub)
						dub_mode="1"
						;;
					*)
						echo "Illegal Option"
						exit 1
						;;
					esac
				;;
			s)
				case "${OPTARG}" in
					-*)
						err_func "3f" "Search Query is Not Specified" >&2
						show_help
						exit 6
						;;
					*)
						search_request="${OPTARG}"
						;;
				esac
				;;
			e)
				case "${OPTARG}" in
					-*)
						err_func "3f" "Episode Query is Not Specified" >&2
						show_help
						exit 6
						;;
					*)
						epside_selected="${OPTARG}"
						;;
				esac
				;;
			q)
				case "${OPTARG}" in
					High|Normal|Low|high|normal|low)
						quality_picker="${OPTARG}"
						;;
					*)
						err_func "3f" "${OPTARG} is an invalid Option" >&2
						show_help
						exit 6
						;;
				esac
				;;
			t)
				case "${OPTARG}" in
					default|1)
						server="${OPTARG}"
						;;
					*)
						err_func "1f" "${OPTARG} is a Invalid Server Number" >&2
						show_help
						exit 6
						;;
				esac
				;;
			p)
				case "${OPTARG}" in
					[0-9]*)
						search_selected="${OPTARG}"
						;;
					*)
						err_func "1f" "${OPTARG} must be a Digit/Number" >&2
						show_help
						exit 1
						;;
				esac
				;;
			\?)
				err_func "4f" "[ -${OPTARG}: is not valid Argument ]" >&2
				show_help
				exit 6
				;;
			:)
				err_func "4f" "[ -${OPTARG}: Argument must have a Value ]" >&2
				show_help
				exit 6
				;;
		esac
	done
	shift $((OPTIND -1))
}

check_configs
arg_parser "$@"
mainFuncs
